//! Distributed unique ID generator proxy implementation.

use std::net::SocketAddr;
use std::sync::{Arc, Mutex};

use bytes::BytesMut;
use hazelcast_core::protocol::constants::*;
use hazelcast_core::protocol::Frame;
use hazelcast_core::{ClientMessage, HazelcastError, Result};

use crate::connection::ConnectionManager;

/// Default batch size for local ID caching.
const DEFAULT_BATCH_SIZE: usize = 100;

/// A batch of unique IDs generated by the FlakeIdGenerator.
///
/// `IdBatch` is an iterator that yields IDs in increasing order.
/// IDs within a batch are guaranteed to be unique and ordered.
#[derive(Debug, Clone)]
pub struct IdBatch {
    base: i64,
    increment: i64,
    batch_size: usize,
    index: usize,
}

impl IdBatch {
    fn new(base: i64, increment: i64, batch_size: usize) -> Self {
        Self {
            base,
            increment,
            batch_size,
            index: 0,
        }
    }

    /// Returns the base ID of this batch.
    pub fn base(&self) -> i64 {
        self.base
    }

    /// Returns the increment between consecutive IDs.
    pub fn increment(&self) -> i64 {
        self.increment
    }

    /// Returns the total number of IDs in this batch.
    pub fn batch_size(&self) -> usize {
        self.batch_size
    }

    /// Returns the number of remaining IDs in this batch.
    pub fn remaining(&self) -> usize {
        self.batch_size.saturating_sub(self.index)
    }
}

impl Iterator for IdBatch {
    type Item = i64;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.batch_size {
            let id = self.base.saturating_add((self.index as i64).saturating_mul(self.increment));
            self.index += 1;
            Some(id)
        } else {
            None
        }
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        let remaining = self.remaining();
        (remaining, Some(remaining))
    }
}

impl ExactSizeIterator for IdBatch {}

/// A distributed ID generator that produces cluster-wide unique, roughly-ordered IDs.
///
/// `FlakeIdGenerator` produces 64-bit IDs that are:
/// - Unique across the cluster
/// - Roughly ordered by time (IDs generated later are generally larger)
/// - Generated without coordination for high throughput
///
/// The IDs are composed of a timestamp, node ID, and sequence number, similar to
/// Twitter's Snowflake algorithm.
///
/// IDs are cached locally in batches to minimize network round-trips.
pub struct FlakeIdGenerator {
    name: String,
    connection_manager: Arc<ConnectionManager>,
    batch: Mutex<Option<IdBatch>>,
}

impl FlakeIdGenerator {
    /// Creates a new FlakeIdGenerator proxy.
    pub(crate) fn new(name: String, connection_manager: Arc<ConnectionManager>) -> Self {
        Self {
            name,
            connection_manager,
            batch: Mutex::new(None),
        }
    }

    /// Returns the name of this FlakeIdGenerator.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Generates a new unique ID.
    ///
    /// The ID is guaranteed to be unique across the cluster and roughly ordered
    /// by generation time.
    ///
    /// IDs are cached locally in batches to minimize network round-trips.
    /// Multiple calls to `new_id()` will typically return IDs from the local
    /// cache without making network calls.
    pub async fn new_id(&self) -> Result<i64> {
        {
            let mut batch_guard = self.batch.lock().map_err(|_| {
                HazelcastError::Serialization("batch lock poisoned".to_string())
            })?;
            if let Some(ref mut batch) = *batch_guard {
                if let Some(id) = batch.next() {
                    return Ok(id);
                }
            }
        }

        let mut new_batch = self.new_id_batch(DEFAULT_BATCH_SIZE).await?;
        let id = new_batch.next().ok_or_else(|| {
            HazelcastError::Serialization("received empty batch from server".to_string())
        })?;

        {
            let mut batch_guard = self.batch.lock().map_err(|_| {
                HazelcastError::Serialization("batch lock poisoned".to_string())
            })?;
            *batch_guard = Some(new_batch);
        }

        Ok(id)
    }

    /// Generates a batch of unique IDs.
    ///
    /// Batch generation is more efficient than calling `new_id()` multiple times,
    /// as it requires only a single network round-trip.
    ///
    /// # Arguments
    ///
    /// * `batch_size` - The number of IDs to generate (must be > 0)
    ///
    /// # Errors
    ///
    /// Returns an error if `batch_size` is 0 or if a network error occurs.
    pub async fn new_id_batch(&self, batch_size: usize) -> Result<IdBatch> {
        if batch_size == 0 {
            return Err(HazelcastError::Serialization(
                "batch_size must be greater than 0".to_string(),
            ));
        }

        let mut message =
            ClientMessage::create_for_encode_any_partition(FLAKE_ID_GENERATOR_NEW_ID_BATCH);
        message.add_frame(Self::string_frame(&self.name));
        message.add_frame(Self::int_frame(batch_size as i32));

        let response = self.invoke(message).await?;
        Self::decode_id_batch_response(&response)
    }

    fn string_frame(s: &str) -> Frame {
        Frame::with_content(BytesMut::from(s.as_bytes()))
    }

    fn int_frame(value: i32) -> Frame {
        let mut buf = BytesMut::with_capacity(4);
        buf.extend_from_slice(&value.to_le_bytes());
        Frame::with_content(buf)
    }

    async fn invoke(&self, message: ClientMessage) -> Result<ClientMessage> {
        let address = self.get_connection_address().await?;
        self.connection_manager.send_to(address, message).await?;
        self.connection_manager
            .receive_from(address)
            .await?
            .ok_or_else(|| HazelcastError::Connection("connection closed unexpectedly".to_string()))
    }

    async fn get_connection_address(&self) -> Result<SocketAddr> {
        let addresses = self.connection_manager.connected_addresses().await;
        addresses.into_iter().next().ok_or_else(|| {
            HazelcastError::Connection("no connections available".to_string())
        })
    }

    fn decode_id_batch_response(response: &ClientMessage) -> Result<IdBatch> {
        let frames = response.frames();
        if frames.is_empty() {
            return Err(HazelcastError::Serialization("empty response".to_string()));
        }

        let initial_frame = &frames[0];
        if initial_frame.content.len() >= RESPONSE_HEADER_SIZE + 20 {
            let offset = RESPONSE_HEADER_SIZE;
            let base = i64::from_le_bytes([
                initial_frame.content[offset],
                initial_frame.content[offset + 1],
                initial_frame.content[offset + 2],
                initial_frame.content[offset + 3],
                initial_frame.content[offset + 4],
                initial_frame.content[offset + 5],
                initial_frame.content[offset + 6],
                initial_frame.content[offset + 7],
            ]);
            let increment = i64::from_le_bytes([
                initial_frame.content[offset + 8],
                initial_frame.content[offset + 9],
                initial_frame.content[offset + 10],
                initial_frame.content[offset + 11],
                initial_frame.content[offset + 12],
                initial_frame.content[offset + 13],
                initial_frame.content[offset + 14],
                initial_frame.content[offset + 15],
            ]);
            let batch_size = i32::from_le_bytes([
                initial_frame.content[offset + 16],
                initial_frame.content[offset + 17],
                initial_frame.content[offset + 18],
                initial_frame.content[offset + 19],
            ]) as usize;

            Ok(IdBatch::new(base, increment, batch_size))
        } else {
            Err(HazelcastError::Serialization(
                "invalid ID batch response".to_string(),
            ))
        }
    }
}

impl Clone for FlakeIdGenerator {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            connection_manager: Arc::clone(&self.connection_manager),
            batch: Mutex::new(None),
        }
    }
}

impl std::fmt::Debug for FlakeIdGenerator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("FlakeIdGenerator")
            .field("name", &self.name)
            .field("connection_manager", &self.connection_manager)
            .field("batch", &"<Mutex>")
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_flake_id_generator_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<FlakeIdGenerator>();
    }

    #[test]
    fn test_flake_id_generator_clone() {
        fn assert_clone<T: Clone>() {}
        assert_clone::<FlakeIdGenerator>();
    }

    #[test]
    fn test_id_batch_iterator() {
        let batch = IdBatch::new(100, 10, 5);
        let ids: Vec<i64> = batch.collect();
        assert_eq!(ids, vec![100, 110, 120, 130, 140]);
    }

    #[test]
    fn test_id_batch_uniqueness() {
        let batch = IdBatch::new(1000, 1, 100);
        let ids: Vec<i64> = batch.collect();

        let mut unique_ids = ids.clone();
        unique_ids.sort();
        unique_ids.dedup();
        assert_eq!(ids.len(), unique_ids.len(), "all IDs should be unique");
    }

    #[test]
    fn test_id_batch_ordering() {
        let batch = IdBatch::new(0, 5, 10);
        let ids: Vec<i64> = batch.collect();

        for window in ids.windows(2) {
            assert!(
                window[0] < window[1],
                "IDs should be strictly increasing: {} < {}",
                window[0],
                window[1]
            );
        }
    }

    #[test]
    fn test_id_batch_size_hint() {
        let mut batch = IdBatch::new(0, 1, 5);
        assert_eq!(batch.size_hint(), (5, Some(5)));
        assert_eq!(batch.len(), 5);

        batch.next();
        assert_eq!(batch.size_hint(), (4, Some(4)));
        assert_eq!(batch.len(), 4);
    }

    #[test]
    fn test_id_batch_remaining() {
        let mut batch = IdBatch::new(0, 1, 3);
        assert_eq!(batch.remaining(), 3);

        batch.next();
        assert_eq!(batch.remaining(), 2);

        batch.next();
        batch.next();
        assert_eq!(batch.remaining(), 0);

        batch.next();
        assert_eq!(batch.remaining(), 0);
    }

    #[test]
    fn test_id_batch_empty() {
        let batch = IdBatch::new(0, 1, 0);
        let ids: Vec<i64> = batch.collect();
        assert!(ids.is_empty());
    }

    #[test]
    fn test_id_batch_single() {
        let batch = IdBatch::new(42, 1, 1);
        let ids: Vec<i64> = batch.collect();
        assert_eq!(ids, vec![42]);
    }

    #[test]
    fn test_id_batch_accessors() {
        let batch = IdBatch::new(100, 50, 10);
        assert_eq!(batch.base(), 100);
        assert_eq!(batch.increment(), 50);
        assert_eq!(batch.batch_size(), 10);
    }

    #[test]
    fn test_id_batch_clone() {
        let batch1 = IdBatch::new(0, 1, 5);
        let batch2 = batch1.clone();

        let ids1: Vec<i64> = batch1.collect();
        let ids2: Vec<i64> = batch2.collect();
        assert_eq!(ids1, ids2);
    }

    #[test]
    fn test_batch_mutex_initialized() {
        fn assert_has_mutex<T>(_: &std::sync::Mutex<T>) {}
        
        let batch = IdBatch::new(0, 1, 5);
        let mutex = std::sync::Mutex::new(Some(batch));
        assert_has_mutex(&mutex);
        
        let guard = mutex.lock().unwrap();
        assert!(guard.is_some());
    }

    #[test]
    fn test_default_batch_size() {
        assert_eq!(DEFAULT_BATCH_SIZE, 100);
    }

    #[test]
    fn test_string_frame() {
        let frame = FlakeIdGenerator::string_frame("test-generator");
        assert_eq!(&frame.content[..], b"test-generator");
    }

    #[test]
    fn test_int_frame() {
        let frame = FlakeIdGenerator::int_frame(100);
        assert_eq!(frame.content.len(), 4);
        assert_eq!(
            i32::from_le_bytes(frame.content[..4].try_into().unwrap()),
            100
        );
    }
}
